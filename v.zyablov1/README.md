# Описание
Репозиторий с решениями задач для "солярки"[^1] по дисциплине "Операционные системы" НГУ в 2024 году.

[^1]:*Linux mephisto 3.16.0-10-686-pae #1 SMP Debian 3.16.81-1 (2020-01-17) i686 GNU/Linux*

# Использование
Для каждой выполненной задачи с номером `$i` есть папка `task$i`, содержащая:
 + исходный код
 + Makefile

Некоторые задачи требуют стороннего пользователя. Для его создания воспользуйтесь командой:
```bash
echo "Enter new user's name:"; read username; sudo useradd -m "$username"
```
Чтобы очистить проект от собранных запускаемых файлов можете выполнить:
```
./scripts/delete_executables.sh
```

# Источники
[Mikhail_Vays](https://github.com/vkinsu/23930/tree/main/Mikhail_Vays): 9,10, 17,18   
[kireev](https://github.com/vkinsu/23930/tree/main/kireev): 8   
[Chat GPT](https://chatgpt.com): 2,  21,25,  26,27,28,  30,31,32   
[a.tishkin1](https://github.com/vkinsu/23933/tree/main/a.tishkin1): 1,3,4,5,6,7    
(Они не соглашались)

# Как использовать решения одногруппников
1. Находим донора: имя пользователя `${username}` и окончание номера его группы `${i_group}`.
2. Смотрим на GitHub путь к решению `"${folder_name}/${file_name}"`.
3. Применяем скрипт для скачивания
```
./scripts/download_solution.sh ${i_group} ${username} "${folder_name}/${file_name}"
```
Например для url-пути `https://github.com/vkinsu/23930/blob/main/Mikhail_Vays/task17/task17.c` такие параметры:
```
./scripts/download_solution.sh 0 Mikhail_Vays "task17/task17.c"
```

# Пояснения
## Различия между асинхронным и синхронным подходами
1. Синхронный подход (с использованием `select`):
   * Основная идея: сервер в цикле опрашивает все зарегистрированные файловые дескрипторы (`select`) и проверяет, доступны ли данные для чтения или записи.
   * Поток выполнения (основной цикл) блокируется на вызове `select` до появления событий (например, новых подключений или данных от клиента).
   * После возвращения `select` сервер вручную проверяет каждый дескриптор, чтобы обработать соответствующее событие.  
2. Асинхронный подход (с использованием `epoll`):
   * Основная идея: сервер использует механизм событий (`epoll`), который уведомляет, когда определённый файловый дескриптор готов к операциям (чтение/запись).
   * Асинхронный подход более эффективен для большого числа клиентов, так как система ядра сама отслеживает активные дескрипторы, избегая ручного опроса всех.
   * В отличие от `select`, `epoll` не требует обновления списка наблюдаемых дескрипторов на каждом цикле.

**Ключевое различие:**
Асинхронный ввод-вывод (`epoll`) минимизирует работу в пространстве пользователя и обращение к ядру (системные вызовы), что позволяет значительно улучшить производительность при большом числе соединений. Синхронный ввод-вывод (`select`) более универсален, но менее эффективен для масштабируемых задач.

## Что такое `poll(2)` и как он отличается от `select(3C)`
`select(3C)`:  
   * Позволяет мониторить несколько дескрипторов на возможность чтения, записи или ошибок.
   * Использует фиксированный массив (`fd_set`) для управления файлами.
   * Этот массив имеет ограничение на количество дескрипторов (обычно 1024).
   * Требует полного обновления этого массива при каждом вызове, что увеличивает накладные расходы.  

`poll(2)`:  
   * Развивает идею select, устраняя ограничения на количество дескрипторов.
   * Работает с динамическим массивом структур struct pollfd, где каждая структура указывает:
   * Эффективен для большего числа дескрипторов, так как его структура данных проще в управлении.

**Вывод:**
`poll` — более современный и универсальный механизм, заменяющий `select`, но он всё ещё остаётся синхронным.

## Что такое `<aio.h>`?
`<aio.h>` — это заголовочный файл, содержащий интерфейс для асинхронного ввода-вывода (AIO) в Unix-подобных системах, таких как Linux. Этот интерфейс позволяет выполнять операции ввода-вывода (например, чтение или запись в файлы) асинхронно, то есть без блокировки текущего потока выполнения программы. Он используется для неблокирующего доступа к данным, обеспечивая более эффективное использование ресурсов, например, при работе с большими объёмами данных или сетевыми соединениями.  
Для работы с асинхронными вызовами обязательно подключение `<aio.h>` и использование его функций для инициирования, проверки статуса и получения результатов операций.
